<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>cynet_utils.spatial API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>cynet_utils.spatial</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import pandas as pd
import numpy as np
import math
import json
from tqdm import tqdm
from time import time
from datetime import datetime, timedelta 
import sys
import warnings
if not sys.warnoptions:
    warnings.simplefilter(&#34;ignore&#34;)

import matplotlib.pyplot as plt
import matplotlib.cm
from matplotlib.colors import ListedColormap, LinearSegmentedColormap

import geopy.distance
import geopandas as gpd
import contextily as ctx



def saveFIG(filename=&#39;tmp.pdf&#39;):
    import pylab as plt
    
    plt.subplots_adjust(
        top=1, 
        bottom=0, 
        right=1, 
        left=0, 
        hspace=0, 
        wspace=0)

    plt.margins(0, 0)
    
    # plt.gca().xaxis.set_major_locator(plt.NullLocator())
    # plt.gca().yaxis.set_major_locator(plt.NullLocator())

    plt.savefig(filename, dpi=300, bbox_inches=0, transparent=True) 
    return


def truncate_colormap(cmap, minval=0.0, maxval=1.0, n=100):
    new_cmap = LinearSegmentedColormap.from_list(
        &#39;trunc({n},{a:.2f},{b:.2f})&#39;.format(n=cmap.name, a=minval, b=maxval),
        cmap(np.linspace(minval, maxval, n)))
    return new_cmap


def lighten_color(color, amount=0.5):
    
    &#34;&#34;&#34;
    By Ian Hincks from stack overflow
    Lightens the given color by multiplying (1-luminosity) by the given amount.
    Input can be matplotlib color string, hex string, or RGB tuple.

    Examples:
    &gt;&gt; lighten_color(&#39;g&#39;, 0.3)
    &gt;&gt; lighten_color(&#39;#F034A3&#39;, 0.6)
    &gt;&gt; lighten_color((.3,.55,.1), 0.5)
    &#34;&#34;&#34;
    
    import matplotlib.colors as mc
    import colorsys
    try:
        c = mc.cnames[color]
    except:
        c = color
    c = colorsys.rgb_to_hls(*mc.to_rgb(c))
    return colorsys.hls_to_rgb(c[0], 1 - amount * (1 - c[1]), c[2])



# =========================== DF column names ==========================START
day_col = &#39;day&#39;
actual_event_col = &#39;actual_event&#39;
variable_col = &#39;target&#39;
source_col = &#39;source&#39;
predictin_col = &#39;predictions&#39;
lon_col = &#39;lon2&#39;
lat_col = &#39;lat2&#39;
source = None
grace = 1
# =========================== DF column names ==========================END


def df_intersect(df1, df2, columns=[]):
    df1__ = df1[columns]
    df2__ = df2[columns]

    df1__m = df1__.apply(lambda x: hash(tuple(x)), axis=1)
    df2__m = df2__.apply(lambda x: hash(tuple(x)), axis=1)

    df_ = df1[df1__m.isin(df2__m)]

    return df_


def df_setdiff(df1, df2, columns=[]):
    df1__ = df1[columns]
    df2__ = df2[columns]

    df1__m = df1__.apply(lambda x: hash(tuple(x)), axis=1)
    df2__m = df2__.apply(lambda x: hash(tuple(x)), axis=1)

    df_ = df1[~df1__m.isin(df2__m)]

    return df_


def df_union(df_1, df_2, columns=[], count_only=False):

    dfh_1 = df_1[columns].apply(lambda x: hash(tuple(x)), axis=1)
    dfh_2 = df_2[columns].apply(lambda x: hash(tuple(x)), axis=1)
    
    diff = df_1[~dfh_1.isin(dfh_2)]
    union = pd.concat([diff, df_2], axis=0, sort=False)
    if count_only:
        return len(union)
    else:
        return union
    

def transCMAP(cmap=plt.cm.RdBu,linear=True):
    cmap1 = cmap(np.arange(cmap.N))
    if linear:
        cmap1[:,-1] = np.linspace(0, 1, cmap.N)
    else:
        cmap1[:,-1] = np.logspace(0, 1, cmap.N)
    return ListedColormap(cmap1)


def getHausdorf(coord,pt):
    return np.min([geopy.distance.distance(pt,i).miles for i in coord])


def getHausdorf_df(df, pt, EPS=0.0001):
    if len(df) == 0:
        return np.inf, []
    
    while True:
        T = [tuple(i) for i in df[(np.abs(df.lat-pt[0])&lt;EPS) 
              &amp; (np.abs(df.lon-pt[1])&lt;EPS)].values]
        if len(T)&gt;0:
            break
        else:
            EPS=2*EPS
    return getHausdorf(T,tuple(pt)),T


def get_intensity(intensity,lon_mesh,lat_mesh,pt_,sigma=3,radius=2):
    &#39;&#39;&#39;
    single point spread calculation with Gaussian diffusion
    &#39;&#39;&#39;
    lon_del=lon_mesh[0,:]
    lat_del=lat_mesh[:,0]
    lon_index=np.arange(len(lon_del))[(pt_[1]-lon_del&lt;radius)*(pt_[1]-lon_del&gt;-radius)]
    lat_index=np.arange(len(lat_del))[(pt_[0]-lat_del&lt;radius)*(pt_[0]-lat_del&gt;-radius)]
    mu=np.mean(lon_index)
    bins=lon_index
    intensity_lon=1/(sigma*np.sqrt(2*np.pi))*np.exp(-(bins - mu)**2/(2 * sigma**2))

    mu=np.mean(lat_index)
    bins=lat_index
    intensity_lat=1/(sigma*np.sqrt(2*np.pi))*np.exp(-(bins - mu)**2/(2 * sigma**2))
    for i in np.arange(len(lon_index)):
        for j in np.arange(len(lat_index)):
            intensity[lat_index[j],lon_index[i]]=intensity[lat_index[j],lon_index[i]]                +intensity_lon[i]*intensity_lat[j]
    return intensity


def get_mesh(df0,lat_min,lat_max,lon_min,lon_max,radius=2,detail=0.25):
    coord_=df0[[lat_col,lon_col]].values
    lon_grid=np.arange(lon_min-radius,lon_max+radius,detail)
    lat_grid=np.arange(lat_min-radius,lat_max+radius,detail)
    lon_mesh,lat_mesh=np.meshgrid(lon_grid,lat_grid)
    return lon_mesh,lat_mesh,coord_


def get_prediction(
        df,
        days,
        types,
        lat_min,
        lat_max,
        lon_min,
        lon_max,
        sigma=3.5, #=======YI made sigma a parameter
        radius=0.01,
        detail=0.2,
        Z=1.0,
        miles=50, #=======YI made miles in spatial relaxation a paramter
        RETURN_PRED=False
    ):

    # =========================== DF column names ==========================START
    day_col = &#39;day&#39;
    actual_event_col = &#39;actual_event&#39;
    variable_col = &#39;target&#39;
    source_col = &#39;source&#39;
    predictin_col = &#39;predictions&#39;
    lon_col = &#39;lon2&#39;
    lat_col = &#39;lat2&#39;
    source = None
    grace = 1
    # =========================== DF column names ==========================END

    df = df[df[day_col].between(days - grace,days + grace)]
    df = df[df[variable_col].isin(types)]
    # df = df[df[source_col] == source]
    
    df_gnd = df[(df[day_col]==days) &amp; (df[actual_event_col]==1)]
    df_prd0 = df[(df[day_col]==days) &amp; (df[predictin_col]==1)]
    df_prd1 = df[(df[day_col]==days - grace) &amp; (df[predictin_col]==1)]
    df_prd2 = df[(df[day_col]==days + grace) &amp; (df[predictin_col]==1)]
    
    df_prd0_tp = df_prd0[df_prd0[actual_event_col]==1]


    # UPDXX calculate tp
    df_gndB = df[(df[day_col]==days-grace) &amp; (df[actual_event_col]==1)]
    df_gndF = df[(df[day_col]==days+grace) &amp; (df[actual_event_col]==1)]    
    df_tpB = df_intersect(df_prd0,df_gndB, columns=[lat_col, lon_col])
    df_tpF = df_intersect(df_prd0,df_gndF, columns=[lat_col, lon_col])
    df_tp = df_union(
        df_union(df_prd0_tp, df_tpB, columns=[lat_col, lon_col]),
        df_tpF,
        columns=[lat_col, lon_col])
    tp = df_tp.index.size
    
    df_fp = df_setdiff(df_prd0,df_tp,columns=[lat_col, lon_col])
    fp = df_fp.index.size
    
    df_fn0 = df[(df[day_col]==days) &amp; (df[actual_event_col]==1) &amp; (df[predictin_col]==0)]
    df_fn1 = df[(df[day_col]==days - grace)  &amp; (df[predictin_col]==0)]
    df_fn2 = df[(df[day_col]==days + grace)  &amp; (df[predictin_col]==0)]
    df_fn = df_intersect(df_intersect(df_fn0,df_fn1,columns=[lat_col, lon_col]),
                      df_fn2,columns=[lat_col, lon_col])
    fn= df_fn.index.size
    
    #print(&#39;tmporal comp: --&gt; &#39;, &#39;tp &#39;,tp, &#39; fp &#39;, fp, &#39; fn &#39;,fn)
        
    # SPATIAL ADJUSTMENT
    lon_grid = np.arange(lon_min - radius, lon_max + radius, detail)
    lat_grid = np.arange(lat_min - radius, lat_max + radius, detail)
    lon_mesh, lat_mesh = np.meshgrid(lon_grid,lat_grid)
    
    lon_mesh0, lat_mesh0, coord_= get_mesh(
        df_prd0,
        lat_min,
        lat_max,
        lon_min,
        lon_max,
        radius=radius,
        detail=detail)
    
    intensity = np.zeros(lat_mesh0.shape)
    for i in coord_:
        intensity = get_intensity(
            intensity,
            lon_mesh0,
            lat_mesh0,
            i,
            sigma=sigma,
            radius=radius)
        
    intensity0 = np.multiply(intensity, (intensity &gt; Z))
    intensity0=(1. / intensity0.max()) * intensity0
    
    lon_del=lon_mesh0[0,:]
    lat_del=lat_mesh0[:,0]
    A=(intensity0&gt;Z).nonzero()
    coordNZ=[(lat_del[A[0][i]],lon_del[A[1][i]]) for i in np.arange(len(A[0]))]
    df_cnz=pd.DataFrame(coordNZ,columns=[&#39;lat&#39;,&#39;lon&#39;])

    xgfp = np.array([getHausdorf_df(df_cnz,tuple(i),EPS=0.01)[0] for i in (df_fp[[lat_col,lon_col]].drop_duplicates().values)])
    fp = np.sum(xgfp &lt; miles)
    
    xgfn = np.array([getHausdorf_df(df_cnz, tuple(i), EPS=0.01)[0] for i in (df_fn[[lat_col,lon_col]].drop_duplicates().values)])
    fn = np.sum(xgfn &gt; 2 * miles)
    
    df_tp_0 = df_intersect(df_tp, df_prd0,columns=[lat_col, lon_col])

    if RETURN_PRED:
        return fn, tp, fp, tp/(tp+fp), tp/(tp+fn), lon_mesh0, lat_mesh0, intensity, intensity0, df_gnd, df_fn,df_tp,df_fp,df_tp_0,df_prd0
    
    return fn, tp, fp, tp/(tp+fp), tp/(tp+fn), lon_mesh0, lat_mesh0, intensity, intensity0, df_gnd, df_fn,df_tp,df_fp,df_tp_0</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="cynet_utils.spatial.df_intersect"><code class="name flex">
<span>def <span class="ident">df_intersect</span></span>(<span>df1, df2, columns=[])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def df_intersect(df1, df2, columns=[]):
    df1__ = df1[columns]
    df2__ = df2[columns]

    df1__m = df1__.apply(lambda x: hash(tuple(x)), axis=1)
    df2__m = df2__.apply(lambda x: hash(tuple(x)), axis=1)

    df_ = df1[df1__m.isin(df2__m)]

    return df_</code></pre>
</details>
</dd>
<dt id="cynet_utils.spatial.df_setdiff"><code class="name flex">
<span>def <span class="ident">df_setdiff</span></span>(<span>df1, df2, columns=[])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def df_setdiff(df1, df2, columns=[]):
    df1__ = df1[columns]
    df2__ = df2[columns]

    df1__m = df1__.apply(lambda x: hash(tuple(x)), axis=1)
    df2__m = df2__.apply(lambda x: hash(tuple(x)), axis=1)

    df_ = df1[~df1__m.isin(df2__m)]

    return df_</code></pre>
</details>
</dd>
<dt id="cynet_utils.spatial.df_union"><code class="name flex">
<span>def <span class="ident">df_union</span></span>(<span>df_1, df_2, columns=[], count_only=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def df_union(df_1, df_2, columns=[], count_only=False):

    dfh_1 = df_1[columns].apply(lambda x: hash(tuple(x)), axis=1)
    dfh_2 = df_2[columns].apply(lambda x: hash(tuple(x)), axis=1)
    
    diff = df_1[~dfh_1.isin(dfh_2)]
    union = pd.concat([diff, df_2], axis=0, sort=False)
    if count_only:
        return len(union)
    else:
        return union</code></pre>
</details>
</dd>
<dt id="cynet_utils.spatial.getHausdorf"><code class="name flex">
<span>def <span class="ident">getHausdorf</span></span>(<span>coord, pt)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getHausdorf(coord,pt):
    return np.min([geopy.distance.distance(pt,i).miles for i in coord])</code></pre>
</details>
</dd>
<dt id="cynet_utils.spatial.getHausdorf_df"><code class="name flex">
<span>def <span class="ident">getHausdorf_df</span></span>(<span>df, pt, EPS=0.0001)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getHausdorf_df(df, pt, EPS=0.0001):
    if len(df) == 0:
        return np.inf, []
    
    while True:
        T = [tuple(i) for i in df[(np.abs(df.lat-pt[0])&lt;EPS) 
              &amp; (np.abs(df.lon-pt[1])&lt;EPS)].values]
        if len(T)&gt;0:
            break
        else:
            EPS=2*EPS
    return getHausdorf(T,tuple(pt)),T</code></pre>
</details>
</dd>
<dt id="cynet_utils.spatial.get_intensity"><code class="name flex">
<span>def <span class="ident">get_intensity</span></span>(<span>intensity, lon_mesh, lat_mesh, pt_, sigma=3, radius=2)</span>
</code></dt>
<dd>
<div class="desc"><p>single point spread calculation with Gaussian diffusion</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_intensity(intensity,lon_mesh,lat_mesh,pt_,sigma=3,radius=2):
    &#39;&#39;&#39;
    single point spread calculation with Gaussian diffusion
    &#39;&#39;&#39;
    lon_del=lon_mesh[0,:]
    lat_del=lat_mesh[:,0]
    lon_index=np.arange(len(lon_del))[(pt_[1]-lon_del&lt;radius)*(pt_[1]-lon_del&gt;-radius)]
    lat_index=np.arange(len(lat_del))[(pt_[0]-lat_del&lt;radius)*(pt_[0]-lat_del&gt;-radius)]
    mu=np.mean(lon_index)
    bins=lon_index
    intensity_lon=1/(sigma*np.sqrt(2*np.pi))*np.exp(-(bins - mu)**2/(2 * sigma**2))

    mu=np.mean(lat_index)
    bins=lat_index
    intensity_lat=1/(sigma*np.sqrt(2*np.pi))*np.exp(-(bins - mu)**2/(2 * sigma**2))
    for i in np.arange(len(lon_index)):
        for j in np.arange(len(lat_index)):
            intensity[lat_index[j],lon_index[i]]=intensity[lat_index[j],lon_index[i]]                +intensity_lon[i]*intensity_lat[j]
    return intensity</code></pre>
</details>
</dd>
<dt id="cynet_utils.spatial.get_mesh"><code class="name flex">
<span>def <span class="ident">get_mesh</span></span>(<span>df0, lat_min, lat_max, lon_min, lon_max, radius=2, detail=0.25)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_mesh(df0,lat_min,lat_max,lon_min,lon_max,radius=2,detail=0.25):
    coord_=df0[[lat_col,lon_col]].values
    lon_grid=np.arange(lon_min-radius,lon_max+radius,detail)
    lat_grid=np.arange(lat_min-radius,lat_max+radius,detail)
    lon_mesh,lat_mesh=np.meshgrid(lon_grid,lat_grid)
    return lon_mesh,lat_mesh,coord_</code></pre>
</details>
</dd>
<dt id="cynet_utils.spatial.get_prediction"><code class="name flex">
<span>def <span class="ident">get_prediction</span></span>(<span>df, days, types, lat_min, lat_max, lon_min, lon_max, sigma=3.5, radius=0.01, detail=0.2, Z=1.0, miles=50, RETURN_PRED=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_prediction(
        df,
        days,
        types,
        lat_min,
        lat_max,
        lon_min,
        lon_max,
        sigma=3.5, #=======YI made sigma a parameter
        radius=0.01,
        detail=0.2,
        Z=1.0,
        miles=50, #=======YI made miles in spatial relaxation a paramter
        RETURN_PRED=False
    ):

    # =========================== DF column names ==========================START
    day_col = &#39;day&#39;
    actual_event_col = &#39;actual_event&#39;
    variable_col = &#39;target&#39;
    source_col = &#39;source&#39;
    predictin_col = &#39;predictions&#39;
    lon_col = &#39;lon2&#39;
    lat_col = &#39;lat2&#39;
    source = None
    grace = 1
    # =========================== DF column names ==========================END

    df = df[df[day_col].between(days - grace,days + grace)]
    df = df[df[variable_col].isin(types)]
    # df = df[df[source_col] == source]
    
    df_gnd = df[(df[day_col]==days) &amp; (df[actual_event_col]==1)]
    df_prd0 = df[(df[day_col]==days) &amp; (df[predictin_col]==1)]
    df_prd1 = df[(df[day_col]==days - grace) &amp; (df[predictin_col]==1)]
    df_prd2 = df[(df[day_col]==days + grace) &amp; (df[predictin_col]==1)]
    
    df_prd0_tp = df_prd0[df_prd0[actual_event_col]==1]


    # UPDXX calculate tp
    df_gndB = df[(df[day_col]==days-grace) &amp; (df[actual_event_col]==1)]
    df_gndF = df[(df[day_col]==days+grace) &amp; (df[actual_event_col]==1)]    
    df_tpB = df_intersect(df_prd0,df_gndB, columns=[lat_col, lon_col])
    df_tpF = df_intersect(df_prd0,df_gndF, columns=[lat_col, lon_col])
    df_tp = df_union(
        df_union(df_prd0_tp, df_tpB, columns=[lat_col, lon_col]),
        df_tpF,
        columns=[lat_col, lon_col])
    tp = df_tp.index.size
    
    df_fp = df_setdiff(df_prd0,df_tp,columns=[lat_col, lon_col])
    fp = df_fp.index.size
    
    df_fn0 = df[(df[day_col]==days) &amp; (df[actual_event_col]==1) &amp; (df[predictin_col]==0)]
    df_fn1 = df[(df[day_col]==days - grace)  &amp; (df[predictin_col]==0)]
    df_fn2 = df[(df[day_col]==days + grace)  &amp; (df[predictin_col]==0)]
    df_fn = df_intersect(df_intersect(df_fn0,df_fn1,columns=[lat_col, lon_col]),
                      df_fn2,columns=[lat_col, lon_col])
    fn= df_fn.index.size
    
    #print(&#39;tmporal comp: --&gt; &#39;, &#39;tp &#39;,tp, &#39; fp &#39;, fp, &#39; fn &#39;,fn)
        
    # SPATIAL ADJUSTMENT
    lon_grid = np.arange(lon_min - radius, lon_max + radius, detail)
    lat_grid = np.arange(lat_min - radius, lat_max + radius, detail)
    lon_mesh, lat_mesh = np.meshgrid(lon_grid,lat_grid)
    
    lon_mesh0, lat_mesh0, coord_= get_mesh(
        df_prd0,
        lat_min,
        lat_max,
        lon_min,
        lon_max,
        radius=radius,
        detail=detail)
    
    intensity = np.zeros(lat_mesh0.shape)
    for i in coord_:
        intensity = get_intensity(
            intensity,
            lon_mesh0,
            lat_mesh0,
            i,
            sigma=sigma,
            radius=radius)
        
    intensity0 = np.multiply(intensity, (intensity &gt; Z))
    intensity0=(1. / intensity0.max()) * intensity0
    
    lon_del=lon_mesh0[0,:]
    lat_del=lat_mesh0[:,0]
    A=(intensity0&gt;Z).nonzero()
    coordNZ=[(lat_del[A[0][i]],lon_del[A[1][i]]) for i in np.arange(len(A[0]))]
    df_cnz=pd.DataFrame(coordNZ,columns=[&#39;lat&#39;,&#39;lon&#39;])

    xgfp = np.array([getHausdorf_df(df_cnz,tuple(i),EPS=0.01)[0] for i in (df_fp[[lat_col,lon_col]].drop_duplicates().values)])
    fp = np.sum(xgfp &lt; miles)
    
    xgfn = np.array([getHausdorf_df(df_cnz, tuple(i), EPS=0.01)[0] for i in (df_fn[[lat_col,lon_col]].drop_duplicates().values)])
    fn = np.sum(xgfn &gt; 2 * miles)
    
    df_tp_0 = df_intersect(df_tp, df_prd0,columns=[lat_col, lon_col])

    if RETURN_PRED:
        return fn, tp, fp, tp/(tp+fp), tp/(tp+fn), lon_mesh0, lat_mesh0, intensity, intensity0, df_gnd, df_fn,df_tp,df_fp,df_tp_0,df_prd0
    
    return fn, tp, fp, tp/(tp+fp), tp/(tp+fn), lon_mesh0, lat_mesh0, intensity, intensity0, df_gnd, df_fn,df_tp,df_fp,df_tp_0</code></pre>
</details>
</dd>
<dt id="cynet_utils.spatial.lighten_color"><code class="name flex">
<span>def <span class="ident">lighten_color</span></span>(<span>color, amount=0.5)</span>
</code></dt>
<dd>
<div class="desc"><p>By Ian Hincks from stack overflow
Lightens the given color by multiplying (1-luminosity) by the given amount.
Input can be matplotlib color string, hex string, or RGB tuple.</p>
<p>Examples:</p>
<blockquote>
<blockquote>
<p>lighten_color('g', 0.3)
lighten_color('#F034A3', 0.6)
lighten_color((.3,.55,.1), 0.5)</p>
</blockquote>
</blockquote></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lighten_color(color, amount=0.5):
    
    &#34;&#34;&#34;
    By Ian Hincks from stack overflow
    Lightens the given color by multiplying (1-luminosity) by the given amount.
    Input can be matplotlib color string, hex string, or RGB tuple.

    Examples:
    &gt;&gt; lighten_color(&#39;g&#39;, 0.3)
    &gt;&gt; lighten_color(&#39;#F034A3&#39;, 0.6)
    &gt;&gt; lighten_color((.3,.55,.1), 0.5)
    &#34;&#34;&#34;
    
    import matplotlib.colors as mc
    import colorsys
    try:
        c = mc.cnames[color]
    except:
        c = color
    c = colorsys.rgb_to_hls(*mc.to_rgb(c))
    return colorsys.hls_to_rgb(c[0], 1 - amount * (1 - c[1]), c[2])</code></pre>
</details>
</dd>
<dt id="cynet_utils.spatial.saveFIG"><code class="name flex">
<span>def <span class="ident">saveFIG</span></span>(<span>filename='tmp.pdf')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def saveFIG(filename=&#39;tmp.pdf&#39;):
    import pylab as plt
    
    plt.subplots_adjust(
        top=1, 
        bottom=0, 
        right=1, 
        left=0, 
        hspace=0, 
        wspace=0)

    plt.margins(0, 0)
    
    # plt.gca().xaxis.set_major_locator(plt.NullLocator())
    # plt.gca().yaxis.set_major_locator(plt.NullLocator())

    plt.savefig(filename, dpi=300, bbox_inches=0, transparent=True) 
    return</code></pre>
</details>
</dd>
<dt id="cynet_utils.spatial.transCMAP"><code class="name flex">
<span>def <span class="ident">transCMAP</span></span>(<span>cmap=&lt;matplotlib.colors.LinearSegmentedColormap object&gt;, linear=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transCMAP(cmap=plt.cm.RdBu,linear=True):
    cmap1 = cmap(np.arange(cmap.N))
    if linear:
        cmap1[:,-1] = np.linspace(0, 1, cmap.N)
    else:
        cmap1[:,-1] = np.logspace(0, 1, cmap.N)
    return ListedColormap(cmap1)</code></pre>
</details>
</dd>
<dt id="cynet_utils.spatial.truncate_colormap"><code class="name flex">
<span>def <span class="ident">truncate_colormap</span></span>(<span>cmap, minval=0.0, maxval=1.0, n=100)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def truncate_colormap(cmap, minval=0.0, maxval=1.0, n=100):
    new_cmap = LinearSegmentedColormap.from_list(
        &#39;trunc({n},{a:.2f},{b:.2f})&#39;.format(n=cmap.name, a=minval, b=maxval),
        cmap(np.linspace(minval, maxval, n)))
    return new_cmap</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="cynet_utils" href="index.html">cynet_utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="cynet_utils.spatial.df_intersect" href="#cynet_utils.spatial.df_intersect">df_intersect</a></code></li>
<li><code><a title="cynet_utils.spatial.df_setdiff" href="#cynet_utils.spatial.df_setdiff">df_setdiff</a></code></li>
<li><code><a title="cynet_utils.spatial.df_union" href="#cynet_utils.spatial.df_union">df_union</a></code></li>
<li><code><a title="cynet_utils.spatial.getHausdorf" href="#cynet_utils.spatial.getHausdorf">getHausdorf</a></code></li>
<li><code><a title="cynet_utils.spatial.getHausdorf_df" href="#cynet_utils.spatial.getHausdorf_df">getHausdorf_df</a></code></li>
<li><code><a title="cynet_utils.spatial.get_intensity" href="#cynet_utils.spatial.get_intensity">get_intensity</a></code></li>
<li><code><a title="cynet_utils.spatial.get_mesh" href="#cynet_utils.spatial.get_mesh">get_mesh</a></code></li>
<li><code><a title="cynet_utils.spatial.get_prediction" href="#cynet_utils.spatial.get_prediction">get_prediction</a></code></li>
<li><code><a title="cynet_utils.spatial.lighten_color" href="#cynet_utils.spatial.lighten_color">lighten_color</a></code></li>
<li><code><a title="cynet_utils.spatial.saveFIG" href="#cynet_utils.spatial.saveFIG">saveFIG</a></code></li>
<li><code><a title="cynet_utils.spatial.transCMAP" href="#cynet_utils.spatial.transCMAP">transCMAP</a></code></li>
<li><code><a title="cynet_utils.spatial.truncate_colormap" href="#cynet_utils.spatial.truncate_colormap">truncate_colormap</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>